<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/13/java%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2022/08/13/java%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="java八股文"><a href="#java八股文" class="headerlink" title="java八股文"></a>java八股文</h1><h2 id="1-为什么重写-equals-还要重写-hashcode？"><a href="#1-为什么重写-equals-还要重写-hashcode？" class="headerlink" title="1.为什么重写 equals 还要重写 hashcode？"></a>1.为什么重写 equals 还要重写 hashcode？</h2><p>当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。 </p><p>所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。  </p><p>所以，Java对于eqauls方法和hashCode方法是这样规定的：</p><p>1、如果两个对象相同，那么它们的hashCode值一定要相同；</p><p>2、如果两个对象的hashCode相同，它们并不一定相同 </p><h2 id="2-和-equals-比较的区别"><a href="#2-和-equals-比较的区别" class="headerlink" title="2.== 和 equals 比较的区别"></a>2.== 和 equals 比较的区别</h2><p>==是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</p><p>==使用情况如下：</p><p>a) 基本类型，比较的是值</p><p>b) 引用类型，比较的是地址</p><p>c) 不能比较没有父子关系的两个对象</p><p>equals()方法使用如下：</p><p>a) 系统类一般已经重写了equals()，比较的是内容。</p><p>b) 用户自定义类如果没有重写equals()，将调用父类的equals （比如是Object），而Object的equals的比较是地址（return (this == obj);）</p><p>c) 用户自定义类需要重写父类的equals()</p><p>注意：Object的==和equals比较的都是地址，作用相同。</p><h2 id="3-为啥有时会出现-4-0-3-6-0-40000001-这种现象？"><a href="#3-为啥有时会出现-4-0-3-6-0-40000001-这种现象？" class="headerlink" title="3.为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？"></a>3.为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？</h2><p>这种舍入误差的主要原因是：<br>浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。<br>这 就好像十进制无法精确地表示分数 1/3—样。<br>如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecimal类。</p><h2 id="4-final-关键字的作用"><a href="#4-final-关键字的作用" class="headerlink" title="4.final 关键字的作用"></a>4.final 关键字的作用</h2><p>final类:不可被继承，如java.lang.Math就是一个 final类，不可被继承。</p><p>final变量:在初始化后不可改变变量值，用于常量定义。如果final变量是引用变量，则不可以改变它的引用对象，但可以改变对象的属性。final修饰的变量是一个常量。只能被赋值一次</p><p>final方法:不可被重写</p><p>定义常量:</p><p>//static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。</p><p>public static final double pi=3.14;</p><h2 id="5-介绍-Java-的集合类"><a href="#5-介绍-Java-的集合类" class="headerlink" title="5.介绍 Java 的集合类"></a>5.介绍 Java 的集合类</h2><p><strong>1)</strong>    集合类型可以归纳为三种List、Map、Set</p><p><img src="C:\Users\ZhangXL\Desktop\八股\图片\集合.png" alt="集合"></p><p>Map接口和Collection接口是所有集合框架的父接口</p><p>Collection接口的子接口包括：Set接口和List接口</p><p>Map接口的实现类主要有：<strong>HashMap</strong>、TreeMap、Hashtable、LinkedHashMap、<strong>ConcurrentHashMap</strong>以及Properties等</p><p>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</p><p>List接口的实现类主要有：<strong>ArrayList</strong>、<strong>LinkedList</strong>、Stack以及Vector等</p><p> <strong>结构特点</strong></p><p>List 和 Set 是存储单列数据的集合，Map 是存储键和值这样的双列数据的集合；</p><p>List 中存储的数据是有顺序，并且允许重复；</p><p>Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的，</p><p>Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的）；</p><p><strong>实现类</strong></p><p><strong>List</strong> <strong>接口有三个实现类</strong></p><p>LinkedList：基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢；</p><p>ArrayList：基于数组实现，非线程安全的，效率高，便于索引，但不便于插入删除；</p><p>Vector：基于数组实现，线程安全的，效率低。</p><p><strong>Map</strong> <strong>接口有三个实现类</strong></p><p>HashMap：基于 hash 表的 Map 接口实现，非线程安全，高效，<strong>支持</strong> null 值和 null 键；</p><p>HashTable：线程安全，低效，<strong>不支持</strong> <strong>null</strong> <strong>值和 null</strong> <strong>键</strong>；</p><p><strong>HashMap<strong><strong>和HashTable</strong></strong>的 key</strong> <strong>值均不能重复，若添加 key</strong> <strong>相同的键值对，后面的 value</strong> <strong>会自动覆盖前面的 value****，但不会报错。</strong></p><p>LinkedHashMap：是HashMap 的一个子类，保存了记录的插入顺序；</p><p>SortMap 接口：TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序。</p><p><strong>Set</strong> <strong>接口有两个实现类</strong></p><p>HashSet：底层是由 HashMap 实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hashCode()方法；</p><p>LinkedHashSet：继承于HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMap</p><h2 id="6-ArrayList-和-LinkedList-的区别"><a href="#6-ArrayList-和-LinkedList-的区别" class="headerlink" title="6.ArrayList 和 LinkedList 的区别"></a>6.ArrayList 和 LinkedList 的区别</h2><p>相同点：ArrayList 和LinkedList 都是List 接口的实现类，因此都具有List 的特点，即存取有序，可重复；而且都不是线程安全的。</p><p>不同点：ArrayList 基于数组实现，LinkedList 基于双向链表实现。</p><p>ArrayList 基于数组存储数据，因此查询元素时可以直接按照数据下标进行索引，而插入元素时，通常涉及到数据元素的复制和移动，所以查询数据快而插入数据慢； </p><p>LinkedList 基于双向链表存储数据，因此查询元素时需要前向或后向遍历，而插入数据时只需要修改本元素的前后项即可，所以查询数据慢而插入数据快。 </p><p>所以，ArrayList 适合查询多（读多）的场景，LinkedList 适合插入多（写多）的场景。</p><h2 id="7-java-8-有哪些新特性？"><a href="#7-java-8-有哪些新特性？" class="headerlink" title="7.java 8 有哪些新特性？"></a>7.java 8 有哪些新特性？</h2><p>1）Lambda表达式和函数式接口</p><p>Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：<a href="http://www.javacodegeeks.com/2014/03/functional-programming-with-java-8-lambda-expressions-monads.html">函数式开发者</a>非常熟悉这些概念。很多JVM平台上的语言（Groovy、<a href="http://www.javacodegeeks.com/tutorials/scala-tutorials/">Scala</a>等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。</p><p>2）接口的默认方法和静态方法</p><p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。<a href="http://blog.csdn.net/yczz/article/details/50896975">默认方法</a>使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p><p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写</p><p>3）方法引用</p><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p><p>4）重复注解</p><p>自从Java 5中引入<a href="http://www.javacodegeeks.com/2012/08/java-annotations-explored-explained.html">注解</a>以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</p><p>在Java 8中使用**@Repeatable**注解定义重复注解</p><h2 id="8-HashMap-在-jdk-1-7-和-1-8-的区别？"><a href="#8-HashMap-在-jdk-1-7-和-1-8-的区别？" class="headerlink" title="8.HashMap 在 jdk 1.7 和 1.8 的区别？"></a>8.HashMap 在 jdk 1.7 和 1.8 的区别？</h2><p>HashMap(Java8以前)：数组+链表</p><p>HashMap在没有为数组赋予长度时，默认是16。每个元素存储的是链表的头结点，通过hash(key.hashCode())%len取模操作获取要添加的元素在数组中的位置。</p><p>这里有一个极端情况，添加到hash表里的元素的key通过取模操作后总是得到同一个值，即所有元素都分配到同一个桶(bucket)，这样在查询链表时要从头部逐个遍历，hashMap的性能会从O(1)恶化到O(n)</p><p><img src="C:\Users\ZhangXL\Desktop\八股\图片\hashmap-1.png" alt="hashmap-1"></p><p>HashMap(Java8以后)：</p><p>HashMap由 数组+链表+红黑树实现，桶中元素可能为链表，也可能为红黑树。为了提高综合（查询、添加、修改）效率，当桶中元素数量超过TREEIFY_THRESHOLD（默认为8）时，链表存储改为红黑树存储，当桶中元素数量小于UNTREEIFY_THRESHOLD（默认为6）时，红黑树存储改为链表存储</p><p><img src="C:\Users\ZhangXL\Desktop\八股\图片\hashmap-2.png" alt="hashmap-2"></p><p>table即Node&lt;k,v&gt;[] table，Node有两种，分别为链表节点Node和其子类TreeNode（红黑树节点）</p><p>每一个table槽称为桶，用于装hash%table.length的元素                 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>当链表的TREEIFY_THRESHOLD长度超过8时，会将链表转换为红黑树存储。在最坏情况下，hashMap性能会从O(n)提高到O(logn)</p><p>当链表的TREEIFY_THRESHOLD长度低于8时，又会将红黑树转回链表，保持最高的性能</p><p><img src="C:\Users\ZhangXL\Desktop\八股\图片\hashmap-3.png" alt="hashmap-3"></p><p><strong>总结</strong></p><p>HashMap是基于哈希表实现的，用Entry[]来存储数据，而Entry中封装了key、value、hash以及Entry类型的next</p><p>HashMap存储数据是无序的</p><p>hash冲突是通过拉链法解决的</p><p>HashMap的容量永远为2的幂次方，有利于哈希表的散列</p><p>HashMap不支持存储多个相同的key，且只保存一个key为null的值，多个会覆盖</p><p>put过程，是先通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，看是否有相同的key存在，存在，则更新value；不存在则插入到table[index]单向链表的表头，时间复杂度为O(n)</p><p>get过程，通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，然后比对key，找到相同的key，则取出其value，时间复杂度为O(n)</p><p>HashMap是线程不安全的，如果有线程安全需求，推荐使用ConcurrentHashMap。</p><h2 id="9-什么是死锁？死锁产生的条件？"><a href="#9-什么是死锁？死锁产生的条件？" class="headerlink" title="9,什么是死锁？死锁产生的条件？"></a>9,什么是死锁？死锁产生的条件？</h2><p>死锁是最常见的一种线程活性故障。死锁的起因是多个线程之间相互等待对方而被永远暂停（处于非Runnable）。</p><p><strong>死锁的产生必须满足如下四个必要条件：</strong></p><p>资源互斥：一个资源每次只能被一个线程使用</p><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</p><p>不剥夺条件：线程已经获得的资源，在未使用完之前，不能强行剥夺</p><p>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</p><h2 id="10-线程有哪几种状态？"><a href="#10-线程有哪几种状态？" class="headerlink" title="10.线程有哪几种状态？"></a>10.线程有哪几种状态？</h2><h2 id="11-有哪些进程调度算法？"><a href="#11-有哪些进程调度算法？" class="headerlink" title="11.有哪些进程调度算法？"></a>11.有哪些进程调度算法？</h2><ol><li><p>什么是缓冲区溢出</p></li><li><p>计算机网络各层有哪些协议？</p><h2 id="14-TCP-和-UDP-协议的区别？"><a href="#14-TCP-和-UDP-协议的区别？" class="headerlink" title="14.TCP 和 UDP 协议的区别？"></a>14.TCP 和 UDP 协议的区别？</h2><p>1） TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。<br>2） TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。<br>3） TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。<br>4） TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制</p><h2 id="15-TCP-为什么需要三次握手和四次挥手？"><a href="#15-TCP-为什么需要三次握手和四次挥手？" class="headerlink" title="15.TCP 为什么需要三次握手和四次挥手？"></a>15.TCP 为什么需要三次握手和四次挥手？</h2><p>通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余</p><p>有这样一种情况，当A发送一个消息给B，但是由于网络原因，消息被阻塞在了某个节点，然后阻塞的时间超出设定的时间，A会认为这个消息丢失了，然后重新发送消息。</p><p>当A和B通信完成后，这个被A认为失效的消息，到达了B<br>对于B而言，以为这是一个新的请求链接消息，就向A发送确认，<br>对于A而言，它认为没有给B再次发送消息（因为上次的通话已经结束）所有A不会理睬B的这个确认，但是B则会一直等待A的消息</p><p>这就导致了B的时间被浪费（对于服务器而言，CPU等资源是一种浪费），这样是不可行的，这就是为什么不能两次握手的原因了</p><p>第三次握手主要是为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判</p><p>第一次挥手：</p><p>Clien发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>第二次挥手：</p><p>Server收到FIN后，发送一个ACK给Client,Server进入CLOSE_WAIT状态。</p><p>第三次挥手：</p><p>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>第四次挥手：</p><p>Client收到FIN后，Client进入TIME_WAIT状态，发送ACK给Server，Server进入CLOSED状态，完成四次握手</p><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手</p></li><li><p>HTTP 和 HTTPS 协议的区别？</p></li><li><p>MySQL 支持行锁还是表锁？分别有哪些优缺点？</p></li><li><p>Spring 的 IOC 和 AOP 是什么，有哪些优点？</p></li></ol><p>IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><p>利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><p>AOP，面向切面编程是指当需要在某一个方法之前或者之后做一些额外的操作，比如说日志记录，权限判断，异常统计等，可以利用AOP将功能代码从业务逻辑代码中分离出来。实现方法的增强</p><h2 id="12-Spring-框架用到了哪些设计模式？"><a href="#12-Spring-框架用到了哪些设计模式？" class="headerlink" title="12.Spring 框架用到了哪些设计模式？"></a>12.Spring 框架用到了哪些设计模式？</h2><p>工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</p><p>代理设计模式 : Spring AOP 功能的实现。</p><p>单例设计模式 : Spring 中的 Bean 默认都是单例的。</p><p>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p><p>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p><p>适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</p><h2 id="13-介绍-Spring-Bean-的生命周期"><a href="#13-介绍-Spring-Bean-的生命周期" class="headerlink" title="13.介绍 Spring Bean 的生命周期"></a>13.介绍 Spring Bean 的生命周期</h2><p>1.创建前的准备阶段，在bean加载之前，获取spring上下文相关配置并解析，找到bean有关的配置内容</p><p>2.创建实例阶段，通过反射创建bean的实例对象，扫描和解析bean声明的一些属性</p><p>3.依赖注入阶段，检测被实例化的bean是否存在其他依赖，如果存在，将这些依赖注入到bean中，这个阶段还会触发扩展的调用，实现bean初始化前后的回调，赋值等等</p><p>4.容器缓存阶段，把bean保存到ioc容器中缓存起来</p><p>5.销毁实例阶段，在spring应用上下文关闭的时候，销毁spring上下文中所有的bean，调用一些在销毁阶段的方法，完成最后的处理</p><p>bean 生命周期 </p><p>（1）通过构造器创建 bean 实例（无参数构造） </p><p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </p><p>（3）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p><p> （4）bean 可以使用了（对象获取到了） </p><p>（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p><h2 id="14-MyBatis-如何实现延迟加载？"><a href="#14-MyBatis-如何实现延迟加载？" class="headerlink" title="14.MyBatis 如何实现延迟加载？"></a>14.MyBatis 如何实现延迟加载？</h2><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。</p><p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><h2 id="15-介绍-MyBatis-的多级缓存机制"><a href="#15-介绍-MyBatis-的多级缓存机制" class="headerlink" title="15.介绍 MyBatis 的多级缓存机制"></a>15.介绍 MyBatis 的多级缓存机制</h2><h3 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h3><ul><li><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问  </p></li><li><p>使一级缓存失效的四种情况：  </p><ol><li>不同的SqlSession对应不同的一级缓存  </li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ol></li></ul><h3 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h3><ul><li><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取  </p></li><li><p>二级缓存开启的条件</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置</li><li>在映射文件中设置标签<cache /></li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol></li><li><p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p></li></ul><h2 id="16-为什么Redis-是单线程的以及为什么这么快？"><a href="#16-为什么Redis-是单线程的以及为什么这么快？" class="headerlink" title="16.为什么Redis 是单线程的以及为什么这么快？"></a>16.为什么Redis 是单线程的以及为什么这么快？</h2><ul><li>redis完全基于内存,绝大部分请求是纯粹的内存操作,非常快速.</li><li>数据结构简单,对数据操作也简单,redis中的数据结构是专门进行设计的</li><li>采用单线程模型, 避免了不必要的上下文切换和竞争条件, 也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗</li><li>使用了多路IO复用模型,非阻塞IO</li><li>使用底层模型不同,它们之间底层实现方式及与客户端之间的 通信的应用协议不一样,Redis直接构建了自己的VM机制,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求</li></ul><ol><li><p>如何解决提交冲突？</p><p>发生冲突，在IDE里面一般都是对比本地文件和远程分支的文件，然后把远程分支上文件的内容手工修改到本地文件，然后再提交冲突的文件使其保证与远程分支的文件一致，这样才会消除冲突，然后再提交自己修改的部分。特别要注意下，修改本地冲突文件使其与远程仓库的文件保持一致后，需要提交后才能消除冲突，否则无法继续提交。必要时可与同事交流，消除冲突。</p><p>发生冲突，也可以使用命令。</p><p>通过git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改；</p><p>通过git pull命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突；</p><p>通过git stash pop命令，把保存在栈区的修改部分合并到最新的工作空间中；</p></li></ol><ol><li>提交不小心出现误操作，如何撤销？</li></ol><ol><li><p>什么是 Git Flow，它有什么好处</p></li><li><p>如何查看某个进程的运行状态？</p></li><li><p>如何在 Linux 上查看 2 G 的大文件？</p></li><li><p>Linux 软链接和硬链接的区别</p></li><li><p>单例模式有哪些实现方式？有哪些优缺点？请手写其中一种</p></li><li><p>你用过哪些设计模式，为什么用它？</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2></li></ol><ol><li>Redis 有哪些常用的数据结构？</li><li>Redis RDB 和 AOF 持久化的区别，如何选择？</li><li>如何解决缓存击穿、缓存穿透、雪崩问题？</li><li>如何用 Redis 实现点赞功能，怎么设计 Key / Value？</li><li>介绍 JVM 的内存模型？</li><li>JVM 内存为什么要分代？</li><li>介绍一次完整的 GC 流程</li><li>介绍双亲委派模型，为什么需要它？</li></ol><h2 id="1、JDK-和-JRE-有什么区别？"><a href="#1、JDK-和-JRE-有什么区别？" class="headerlink" title="1、JDK 和 JRE 有什么区别？"></a>1、JDK 和 JRE 有什么区别？</h2><p>JDK（Java Development Kit），Java开发工具包</p><p>JRE（Java Runtime Environment），Java运行环境</p><p>JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib就是JVM工作所需要的类库。</p><h2 id="2、-和-equals-的区别是什么？"><a href="#2、-和-equals-的区别是什么？" class="headerlink" title="2、== 和 equals 的区别是什么？"></a>2、== 和 <a href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a> 的区别是什么？</h2><ol><li>对于基本类型，==比较的是值；</li><li>对于引用类型，==比较的是地址；</li><li>equals不能用于基本类型的比较；</li><li>如果没有重写equals，equals就相当于==；</li><li>如果重写了equals方法，equals比较的是对象的内容</li></ol><h2 id="3、final-在-java-中有什么作用？"><a href="#3、final-在-java-中有什么作用？" class="headerlink" title="3、final 在 java 中有什么作用？"></a>3、final 在 java 中有什么作用？</h2><p>1）用来修饰一个引用</p><p> 如果引用为基本数据类型，则该引用为常量，该值无法修改；<br> 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。<br> 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。<br>（2）用来修饰一个方法</p><p>当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p><p>（3）用来修饰类</p><p>当用final修改类时，该类成为最终类，无法被继承。</p><p> 比如常用的String类就是最终类。</p><h2 id="4、java-中的-Math-round-1-5-等于多少？"><a href="#4、java-中的-Math-round-1-5-等于多少？" class="headerlink" title="4、java 中的 Math.round(-1.5) 等于多少？"></a>4、java 中的 Math.round(-1.5) 等于多少？</h2><p>Math提供了三个与取整有关的方法：ceil、floor、round</p><p>（1）ceil：向上取整；</p><p>Math.ceil(11.3) = 12;</p><p>Math.ceil(-11.3) = 11;</p><p>（2）floor：向下取整；</p><p>Math.floor(11.3) = 11;</p><p>Math.floor(-11.3) = -12;</p><p>（3）round：四舍五入；</p><p>加0.5然后向下取整。</p><p>Math.round(11.3) = 11;</p><p>Math.round(11.8) = 12;</p><p>Math.round(-11.3) = -11;</p><p>Math.round(-11.8) = -12;</p><h2 id="5、String-属于基础的数据类型吗？"><a href="#5、String-属于基础的数据类型吗？" class="headerlink" title="5、String 属于基础的数据类型吗？"></a>5、String 属于基础的数据类型吗？</h2><p>不属于。</p><p>八种基本数据类型：byte、short、char、int、long、double、float、boolean。</p><h2 id="6、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#6、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="6、String str=”i”与 String str=new String(“i”)一样吗？"></a>6、String str=”i”与 String str=new String(“i”)一样吗？</h2><p>String str=”i”会将起分配到常量池中，常量池中没有重复的元素，如果常量池中存中i，就将i的地址赋给变量，如果没有就创建一个再赋给变量。</p><p>String str=new String(“i”)会将对象分配到堆中，即使内存一样，还是会重新创建一个新的对象。</p><h2 id="7、如何将字符串反转？"><a href="#7、如何将字符串反转？" class="headerlink" title="7、如何将字符串反转？"></a>7、如何将字符串反转？</h2><p>将对象封装到stringBuilder中，调用reverse方法反转。</p><p><img src="C:\Users\ZhangXL\Desktop\八股\图片\7、如何将字符串反转？.png" alt="7、如何将字符串反转？"></p><h2 id="8、String-类的常用方法都有那些？"><a href="#8、String-类的常用方法都有那些？" class="headerlink" title="8、String 类的常用方法都有那些？"></a>8、String 类的常用方法都有那些？</h2><p>（1）常见String类的获取功能</p><p>length：获取字符串长度；<br>charAt(int index)：获取指定索引位置的字符；<br>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引；<br>substring(int start)：从指定位置开始截取字符串,默认到末尾；<br>substring(int start,int end)：从指定位置开始到指定位置结束截取字符串；</p><p>（2）常见String类的判断功能</p><p>equals(Object obj)： 比较字符串的内容是否相同,区分大小写；<br>contains(String str): 判断字符串中是否包含传递进来的字符串；<br>startsWith(String str): 判断字符串是否以传递进来的字符串开头；<br>endsWith(String str): 判断字符串是否以传递进来的字符串结尾；<br>isEmpty(): 判断字符串的内容是否为空串””；</p><p>（3）常见String类的转换功能</p><p>byte[] getBytes(): 把字符串转换为字节数组；<br>char[] toCharArray(): 把字符串转换为字符数组；<br>String valueOf(char[] chs): 把字符数组转成字符串。valueOf可以将任意类型转为字符串；<br>toLowerCase(): 把字符串转成小写；<br>toUpperCase(): 把字符串转成大写；<br>concat(String str): 把字符串拼接；</p><p>（4）常见String类的其他常用功能</p><p>replace(char old,char new) 将指定字符进行互换<br>replace(String old,String new) 将指定字符串进行互换<br>trim() 去除两端空格<br>int compareTo(String str) 会对照ASCII 码表 从第一个字母进行减法运算 返回的就是这个减法的结果，如果前面几个字母一样会根据两个字符串的长度进行减法运算返回的就是这个减法的结果，如果两个字符串一模一样 返回的就是0。</p><h2 id="9、new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#9、new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="9、new String(“a”) + new String(“b”) 会创建几个对象？"></a>9、new String(“a”) + new String(“b”) 会创建几个对象？</h2><p>对象1：new StringBuilder()</p><p>对象2：new String(“a”)</p><p>对象3：常量池中的”a”</p><p>对象4：new String(“b”)</p><p>对象5：常量池中的”b”</p><p>深入剖析：StringBuilder中的toString()：</p><p>对象6：new String(“ab”)</p><p>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</p><p>附加题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//s1变量记录的地址为：new String</span><br>s1.intern();<span class="hljs-comment">//在字符串常量池中生成&quot;11&quot;。如何理解：jdk6：创建了一个新的对象&quot;11&quot;，也就有新的地址；jdk7：此时常量池中并没有创建&quot;11&quot;，而是创建了一个指向堆空间中new String(&quot;11&quot;)的地址；</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;<br>System.out.println(s1 == s2);<span class="hljs-comment">//jdk6:false;jdk7:true</span><br></code></pre></td></tr></table></figure><h2 id="10、如何将字符串反转？"><a href="#10、如何将字符串反转？" class="headerlink" title="10、如何将字符串反转？"></a>10、如何将字符串反转？</h2><p>添加到StringBuilder中，然后调用reverse()</p><h2 id="11、String-类的常用方法都有那些？"><a href="#11、String-类的常用方法都有那些？" class="headerlink" title="11、String 类的常用方法都有那些？"></a>11、String 类的常用方法都有那些？</h2><p>equals、length、contains、replace、split、hashcode、indexof、substring、trim、toUpperCase、toLowerCase、isEmpty等等。</p><h2 id="12、普通类和抽象类有哪些区别？"><a href="#12、普通类和抽象类有哪些区别？" class="headerlink" title="12、普通类和抽象类有哪些区别？"></a>12、普通类和抽象类有哪些区别？</h2><p>抽象类不能被实例化；<br>抽象类可以有抽象方法，只需申明，无须实现；<br>有抽象方法的类一定是抽象类；<br>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；<br>抽象方法不能声明为静态、不能被static、final修饰。</p><h2 id="13、接口和抽象类有什么区别？"><a href="#13、接口和抽象类有什么区别？" class="headerlink" title="13、接口和抽象类有什么区别？"></a>13、接口和抽象类有什么区别？</h2><p>（1）接口</p><p>接口使用interface修饰；<br>接口不能实例化；<br>类可以实现多个接口；</p><p>①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p><p>（2）抽象类</p><p>抽象类使用abstract修饰；<br>抽象类不能被实例化；<br>抽象类只能单继承；<br>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；<br>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类</p><h2 id="14、java-中-IO-流分为几种？"><a href="#14、java-中-IO-流分为几种？" class="headerlink" title="14、java 中 IO 流分为几种？"></a>14、java 中 IO 流分为几种？</h2><p>（1）按流划分，可以分为输入流和输出流；</p><p>（2）按单位划分，可以分为字节流和字符流；</p><p>字节流：inputStream、outputStream；</p><p>字符流：reader、writer；</p><h2 id="15-说一说String和StringBuffer有什么区别"><a href="#15-说一说String和StringBuffer有什么区别" class="headerlink" title="15.说一说String和StringBuffer有什么区别"></a>15.说一说String和StringBuffer有什么区别</h2><p>tring类是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p><p>StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</p><h2 id="16-说一说StringBuffer和StringBuilder有什么区别"><a href="#16-说一说StringBuffer和StringBuilder有什么区别" class="headerlink" title="16.说一说StringBuffer和StringBuilder有什么区别"></a>16.说一说StringBuffer和StringBuilder有什么区别</h2><p>StringBuffer、StringBuilder都代表可变的字符串对象，它们有共同的父类 AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。不同的是，StringBuffer是线程安全的，而StringBuilder是非线程安全的，所以StringBuilder性能略高。一般情况下，要创建一个内容可变的字符串，建议优先考虑StringBuilder类。</p><h2 id="17-接口和抽象类有什么区别？"><a href="#17-接口和抽象类有什么区别？" class="headerlink" title="17.接口和抽象类有什么区别？"></a>17.接口和抽象类有什么区别？</h2><p>从设计目的上来说，二者有如下的区别：</p><p>接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。</p><p>抽象类体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。</p><p>从使用方式上来说，二者有如下的区别：</p><ul><li>接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。</li><li>接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。</li><li>接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li><li>接口里不能包含初始化块；但抽象类则完全可以包含初始化块。</li><li>一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</li></ul><h2 id="18-创建线程有哪几种方式"><a href="#18-创建线程有哪几种方式" class="headerlink" title="18.创建线程有哪几种方式"></a>18.创建线程有哪几种方式</h2><p>继承Thread重写run(),调用start</p><p>定义runnable接口的实现类，并重写该接口的run()方法，调用start()</p><h2 id="19-mybatis的id能否重复，命名空间能否重复，命名空间的id能否重复？"><a href="#19-mybatis的id能否重复，命名空间能否重复，命名空间的id能否重复？" class="headerlink" title="19.mybatis的id能否重复，命名空间能否重复，命名空间的id能否重复？"></a>19.mybatis的id能否重复，命名空间能否重复，命名空间的id能否重复？</h2><p>可以重复，但是需要映射文件的namespace不同；</p><p>不同的XML映射文件，如果配置了namespace, 那么id可以重复；如果没有配置namespace, 那么id不能重复；</p><p>原因就是namespace+id是作为Map&lt;String,MapperStatement&gt;的key使用的，如果没有namespace， 就剩下id. 那么id重复会导致数据互相覆盖；</p><p>有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同了。<br>总的来说，要么id不一样，可以直接用，要么id一样，但是namespace不一样，使用的时候加上namespace区分。</p><h2 id="20-类加载的生命周期？"><a href="#20-类加载的生命周期？" class="headerlink" title="20.类加载的生命周期？"></a>20.类加载的生命周期？</h2><p>类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段</p><p>类的加载: 查找并加载类的二进制数据</p><p>连接</p><ul><li>验证: 确保被加载的类的正确性</li><li>准备: 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析: 把类中的符号引用转换为直接引用</li></ul><p>初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p><p>使用： 类访问方法区内的数据结构的接口， 对象是Heap区的数据</p><p>卸载： 结束生命周期</p><h2 id="21-类加载器的层次"><a href="#21-类加载器的层次" class="headerlink" title="21.类加载器的层次?"></a>21.类加载器的层次?</h2><p><strong>启动类加载器</strong>: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</p><p>核心类加载器，java开头</p><p><strong>扩展类加载器</strong>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</p><p>扩展类加载器，javax开头</p><p><strong>应用程序类加载器</strong>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>程序员自己写的编译过后的.class文件</p><h2 id="22-Class-forName-和ClassLoader-loadClass-区别"><a href="#22-Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="22. Class.forName()和ClassLoader.loadClass()区别?"></a>22. Class.forName()和ClassLoader.loadClass()区别?</h2><ul><li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</li></ul><h2 id="23-JVM有哪些类加载机制？"><a href="#23-JVM有哪些类加载机制？" class="headerlink" title="23.JVM有哪些类加载机制？"></a>23.JVM有哪些类加载机制？</h2><p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p><p><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p><p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p><p><strong>双亲委派机制</strong>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类</p><p>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p><p>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p><p>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</p><p>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException</p><h2 id="23-多线程使用场景"><a href="#23-多线程使用场景" class="headerlink" title="23.多线程使用场景"></a>23.多线程使用场景</h2><h3 id="1-1-多线程应该最多的场景："><a href="#1-1-多线程应该最多的场景：" class="headerlink" title="1.1 多线程应该最多的场景："></a>1.1 多线程应该最多的场景：</h3><p>web服务器本身； 各种专用服务器（如游戏服务器）；</p><h3 id="1-2多线程的常见应用场景："><a href="#1-2多线程的常见应用场景：" class="headerlink" title="1.2多线程的常见应用场景："></a>1.2多线程的常见应用场景：</h3><p>1、后台任务，例如：定时向大量（100w以上）的用户发送邮件； 2、异步处理，例如：发微博、记录日志等； 3、分布式计算</p><p>卖票</p><h2 id="24-一个java文件中是否可以定义多个类"><a href="#24-一个java文件中是否可以定义多个类" class="headerlink" title="24.一个java文件中是否可以定义多个类"></a>24.一个java文件中是否可以定义多个类</h2><p>一个java文件中可以定义多个类，但是最多只有一个类被public修饰，并且这个类的类名与文件名必须相同，若这个文件中没有public的类，则文件名随便是一个类的名字即可</p><h2 id="25-java锁"><a href="#25-java锁" class="headerlink" title="25.java锁"></a>25.java锁</h2><p>悲观锁：一个共享数据加了悲观锁，那线程每次想操作这个数据前都会假设其他线程也可能会操作这个数据，所以每次操作前都会上锁，这样其他线程想操作这个数据拿不到锁只能阻塞了</p><p>乐观锁：操作数据时不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据</p><p>独占锁：锁一次只能被一个线程所持有。如果一个线程对数据加上排他锁后，那么其他线程不能再对该数据加任何类型的锁。获得独占锁的线程即能读数据又能修改数据</p><p>共享锁：指锁可被多个线程所持有。如果一个线程对数据加上共享锁后，那么其他线程只能对数据再加共享锁，不能加独占锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>互斥锁：是独占锁的一种常规实现，是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。互斥锁一次只能一个线程拥有互斥锁，其他线程只有等待。</p><p>读写锁：是共享锁的一种具体实现。读写锁管理一组锁，一个是只读的锁，一个是写锁。</p><p>读锁可以在没有写锁的时候被多个线程同时持有，而写锁是独占的。写锁的优先级要高于读锁，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。</p><p>读写锁相比于互斥锁并发程度更高，每次只有一个写线程，但是同时可以有多个线程并发读。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/13/java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2022/08/13/java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="1-什么是Spring框架？"><a href="#1-什么是Spring框架？" class="headerlink" title="1.什么是Spring框架？"></a>1.什么是Spring框架？</h2><p>Spring是一种轻量级框架，我们一般说的Spring框架就是Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是核心容器、数据访问/集成、Web、AOP（面向切面编程）、工具、消息和测试模块。比如Core Container中的Core组件是Spring所有组件的核心，Beans组件和Context组件是实现IOC和DI的基础，AOP组件用来实现面向切面编程。</p><h2 id="2-列举一些重要的Spring模块？"><a href="#2-列举一些重要的Spring模块？" class="headerlink" title="2.列举一些重要的Spring模块？"></a>2.列举一些重要的Spring模块？</h2><p>Spring Core：基础，可以说Spring其他所有的功能都依赖于该类库。主要提供IOC和DI功能。</p><p>Spring Aspects：该模块为与AspectJ的集成提供支持。</p><p>Spring AOP：提供面向方面的编程实现。</p><p>Spring JDBC：Java数据库连接。</p><p>Spring JMS：Java消息服务。</p><p>Spring ORM：用于支持Hibernate等ORM工具。</p><p>Spring Web：为创建Web应用程序提供支持。</p><p>Spring Test：提供了对JUnit和TestNG测试的支持。</p><h2 id="3-什么是IOC-如何实现的？"><a href="#3-什么是IOC-如何实现的？" class="headerlink" title="3. 什么是IOC? 如何实现的？"></a>3. 什么是IOC? 如何实现的？</h2><p>IOC（Inversion Of Controll，控制反转）是一种设计思想，就是将原本在程序中手动创建对象的控制权，交给IOC容器来管理，并由IOC容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的，Spring 中的 IoC 的实现原理就是工厂模式加反射机制</p><h2 id="4-什么是AOP-有哪些AOP的概念？"><a href="#4-什么是AOP-有哪些AOP的概念？" class="headerlink" title="4. 什么是AOP? 有哪些AOP的概念？"></a>4. 什么是AOP? 有哪些AOP的概念？</h2><p>AOP（面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p><p>Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理</p><p>当然也可以使用AspectJ，Spring AOP中已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量。我们需要增加新功能也方便，提高了系统的扩展性。日志功能、事务管理和权限管理等场景都用到了AOP。</p><h2 id="5-AOP包含的几个概念"><a href="#5-AOP包含的几个概念" class="headerlink" title="5.AOP包含的几个概念"></a>5.<strong>AOP包含的几个概念</strong></h2><ol><li>Jointpoint（连接点）：具体的切面点点抽象概念，可以是在字段、方法上，Spring中具体表现形式是PointCut（切入点），仅作用在方法上。</li><li>Advice（通知）: 在连接点进行的具体操作，如何进行增强处理的，分为前置、后置、异常、最终、环绕五种情况。</li><li>目标对象：被AOP框架进行增强处理的对象，也被称为被增强的对象。</li><li>AOP代理：AOP框架创建的对象，简单的说，代理就是对目标对象的加强。Spring中的AOP代理可以是JDK动态代理，也可以是CGLIB代理。</li><li>Weaving（织入）：将增强处理添加到目标对象中，创建一个被增强的对象的过程</li></ol><p>总结为一句话就是：在目标对象（target object）的某些方法（jointpoint）添加不同种类的操作（通知、增强操处理），最后通过某些方法（weaving、织入操作）实现一个新的代理目标对象。</p><h2 id="6-AOP-有哪些应用场景？"><a href="#6-AOP-有哪些应用场景？" class="headerlink" title="6.AOP 有哪些应用场景？"></a>6.AOP 有哪些应用场景？</h2><p>记录日志(调用方法后记录日志)</p><p>监控性能(统计方法运行时间)</p><p>权限控制(调用方法前校验是否有权限)</p><p>事务管理(调用方法前开启事务，调用方法后提交关闭事务 )</p><p>缓存优化(第一次调用查询数据库，将查询结果放入内存对象， 第二次调用，直接从内存对象返回，不需要查询数据库 ）</p><h2 id="7-有哪些AOP-Advice通知的类型？"><a href="#7-有哪些AOP-Advice通知的类型？" class="headerlink" title="7. 有哪些AOP Advice通知的类型？"></a>7. 有哪些AOP Advice通知的类型？</h2><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p><ul><li><strong>前置通知</strong>（Before advice） ： 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li><li><strong>后置通知</strong>（After advice） ：这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li><li><strong>返回后通知</strong>（After return advice） ：这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li><li><strong>环绕通知</strong>（Around advice） ：这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li><li><strong>抛出异常后通知</strong>（After throwing advice） ：仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行</li></ul><h2 id="8-AOP-有哪些实现方式？"><a href="#8-AOP-有哪些实现方式？" class="headerlink" title="8.AOP 有哪些实现方式？"></a>8.AOP 有哪些实现方式？</h2><p>实现 AOP 的技术，主要分为两大类：</p><ul><li><p>静态代理</p><p> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</p><ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul></li><li><p>动态代理</p><p> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p><ul><li>JDK 动态代理<ul><li>JDK Proxy 是 Java 语言自带的功能，无需通过加载第三方类实现；</li><li>Java 对 JDK Proxy 提供了稳定的支持，并且会持续的升级和更新，Java 8 版本中的 JDK Proxy 性能相比于之前版本提升了很多；</li><li>JDK Proxy 是通过拦截器加反射的方式实现的；</li><li>JDK Proxy 只能代理实现接口的类；</li><li>JDK Proxy 实现和调用起来比较简单；</li></ul></li><li>CGLIB<ul><li>CGLib 是第三方提供的工具，基于 ASM 实现的，性能比较高；</li><li>CGLib 无需通过接口来实现，它是针对类实现代理，主要是对指定的类生成一个子类，它是通过实现子类的方式来完成调用的</li></ul></li></ul></li></ul><h2 id="9-Spring中的bean的作用域有哪些？"><a href="#9-Spring中的bean的作用域有哪些？" class="headerlink" title="9.Spring中的bean的作用域有哪些？"></a>9.Spring中的bean的作用域有哪些？</h2><p>singleton：唯一bean实例，Spring中的bean默认都是单例的。</p><p>prototype：每次请求都会创建一个新的bean实例。</p><p>request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p><p>session：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。</p><p>global-session：全局session作用域，仅仅在基于Portlet的Web应用中才有意义，Spring5中已经没有了。Portlet是能够生成语义代码（例如HTML）片段的小型Java Web插件。它们基于Portlet容器，可以像Servlet一样处理HTTP请求。但是与Servlet不同，每个Portlet都有不同的会话</p><h2 id="10-Spring中的bean生命周期？"><a href="#10-Spring中的bean生命周期？" class="headerlink" title="10.Spring中的bean生命周期？"></a>10.Spring中的bean生命周期？</h2><p><strong>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类</strong>：</p><ul><li><strong>Bean自身的方法</strong>： 这个包括了Bean本身调用的方法和通过配置文件中<code>&lt;bean&gt;</code>的init-method和destroy-method指定的方法</li><li><strong>Bean级生命周期接口方法</strong>： 这个包括了BeanNameAware、BeanFactoryAware、ApplicationContextAware；当然也包括InitializingBean和DiposableBean这些接口的方法（可以被@PostConstruct和@PreDestroy注解替代)</li><li><strong>容器级生命周期接口方法</strong>： 这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li><li><strong>工厂后处理器接口方法</strong>： 这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用</li></ul><h2 id="11-说说自己对于Spring-MVC的了解？"><a href="#11-说说自己对于Spring-MVC的了解？" class="headerlink" title="11.说说自己对于Spring MVC的了解？"></a>11.说说自己对于Spring MVC的了解？</h2><p>MVC是一种设计模式，Spring MVC是一款很优秀的MVC框架。Spring MVC可以帮助我们进行更简洁的Web层的开发，并且它天生与Spring框架集成。Spring MVC下我们一般把后端项目分为Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层（控制层，返回数据给前台页面）。</p><h2 id="12-Spring-MVC的工作原理了解嘛？"><a href="#12-Spring-MVC的工作原理了解嘛？" class="headerlink" title="12.Spring MVC的工作原理了解嘛？"></a>12.Spring MVC的工作原理了解嘛？</h2><p><img src="C:\Users\ZhangXL\AppData\Roaming\Typora\typora-user-images\image-20220408231041076.png" alt="image-20220408231041076"></p><p>流程说明：</p><p>1.客户端（浏览器）发送请求，直接请求到DispatcherServlet。</p><p>2.DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler。</p><p>3.解析到对应的Handler（也就是我们平常说的Controller控制器）。</p><p>4.HandlerAdapter会根据Handler来调用真正的处理器来处理请求和执行相对应的业务逻辑。</p><p>5.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View。</p><p>6.ViewResolver会根据逻辑View去查找实际的View。</p><p>7.DispatcherServlet把返回的Model传给View（视图渲染）。</p><p>8.把View返回给请求者（浏览器）</p><h2 id="13-Spring框架中用到了哪些设计模式"><a href="#13-Spring框架中用到了哪些设计模式" class="headerlink" title="13. Spring框架中用到了哪些设计模式"></a>13. Spring框架中用到了哪些设计模式</h2><p>1.工厂设计模式：Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象。</p><p>2.代理设计模式：Spring AOP功能的实现。</p><p>3.单例设计模式：Spring中的bean默认都是单例的。</p><p>4.模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到了模板模式。</p><p>5.包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p><p>6.观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用。</p><p>7.适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式、Spring MVC中也是用到了适配器模式适配Controller</p><h2 id="14-Component和-Bean的区别是什么？"><a href="#14-Component和-Bean的区别是什么？" class="headerlink" title="14.@Component和@Bean的区别是什么？"></a>14.@Component和@Bean的区别是什么？</h2><p>1.作用对象不同。@Component注解作用于类，而@Bean注解作用于方法。</p><p>2.@Component注解通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用@ComponentScan注解定义要扫描的路径）。@Bean注解通常是在标有该注解的方法中定义产生这个bean，告诉Spring这是某个类的实例，当我需要用它的时候还给我。</p><p>3.@Bean注解比@Component注解的自定义性更强，而且很多地方只能通过@Bean注解来注册bean。比如当引用第三方库的类需要装配到Spring容器的时候，就只能通过@Bean注解来实现</p><h2 id="15-将一个类声明为Spring的bean的注解有哪些？"><a href="#15-将一个类声明为Spring的bean的注解有哪些？" class="headerlink" title="15.将一个类声明为Spring的bean的注解有哪些？"></a>15.将一个类声明为Spring的bean的注解有哪些？</h2><p>我们一般使用@Autowired注解去自动装配bean。而想要把一个类标识为可以用@Autowired注解自动装配的bean，可以采用以下的注解实现：</p><p>1.@Component注解。通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪一个层，可以使用@Component注解标注。</p><p>2.@Repository注解。对应持久层，即Dao层，主要用于数据库相关操作。</p><p>3.@Service注解。对应服务层，即Service层，主要涉及一些复杂的逻辑，需要用到Dao层（注入）。</p><p>4.@Controller注解。对应Spring MVC的控制层，即Controller层，主要用于接受用户请求并调用Service层的方法返回数据给前端页面</p><h2 id="16-Spring事务管理的方式有几种？"><a href="#16-Spring事务管理的方式有几种？" class="headerlink" title="16.Spring事务管理的方式有几种？"></a>16.Spring事务管理的方式有几种？</h2><p>1.编程式事务：在代码中硬编码（不推荐使用）。</p><p>2.声明式事务：在配置文件中配置（推荐使用），分为基于XML的声明式事务和基于注解的声明式事务</p><h2 id="17-Bean-Factory和ApplicationContext有什么区别？"><a href="#17-Bean-Factory和ApplicationContext有什么区别？" class="headerlink" title="17.Bean Factory和ApplicationContext有什么区别？"></a>17.Bean Factory和ApplicationContext有什么区别？</h2><p>ApplicationContex提供了一种解析文本消息的方法，一种加载文件资源（如图像）的通用方法，它们可以将事件发布到注册为侦听器的bean。此外，可以在应用程序上下文中以声明方式处理容器中的容器或容器上的操作，这些操作必须以编程方式与Bean Factory一起处理。ApplicationContex实现MessageSource，一个用于获取本地化消息的接口，实际的实现是可插入的</p><h2 id="18-如何定义bean的范围？"><a href="#18-如何定义bean的范围？" class="headerlink" title="18.如何定义bean的范围？"></a>18.如何定义bean的范围？</h2><p>在Spring中定义一个时，我们也可以为bean声明一个范围。它可以通过bean定义中的scope属性定义。例如，当Spring每次需要生成一个新的bean实例时，bean’sscope属性就是原型。另一方面，当每次需要Spring都必须返回相同的bean实例时，bean scope属性必须设置为singleton</p><h2 id="19-可以通过多少种方式完成依赖注入"><a href="#19-可以通过多少种方式完成依赖注入" class="headerlink" title="19.可以通过多少种方式完成依赖注入"></a>19.可以通过多少种方式完成依赖注入</h2><p>通常，依赖注入可以通过三种方式完成，即：</p><ul><li>构造函数注入</li><li>setter 注入</li><li>接口注入</li></ul><h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><h2 id="1-什么是SpringBoot？"><a href="#1-什么是SpringBoot？" class="headerlink" title="1.什么是SpringBoot？"></a>1.什么是SpringBoot？</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><ul><li>用来简化Spring应用的初始搭建以及开发过程，使用特定的方式来进行配置</li><li>创建独立的Spring引用程序main方法运行</li><li>嵌入的tomcat无需部署war文件</li><li>简化maven配置</li><li>自动配置Spring添加对应的功能starter自动化配置</li><li>SpringBoot来简化Spring应用开发，约定大于配置，去繁化简</li></ul><h1 id="Redis问题"><a href="#Redis问题" class="headerlink" title="Redis问题"></a>Redis问题</h1><h2 id="1、什么是redis？"><a href="#1、什么是redis？" class="headerlink" title="1、什么是redis？"></a>1、什么是redis？</h2><p><code>Redis</code>(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的高性能非关系型（NoSQL）的键值对数据库。<code>Redis</code> 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。<code>redis</code>每秒可以处理超过 <strong>10万次</strong>读写操作，是已知性能最快的Key-Value DB。另外<code>redis</code>也常用来做分布式锁。</p><h2 id="1-1、redis的优缺点？（招银网络科技）"><a href="#1-1、redis的优缺点？（招银网络科技）" class="headerlink" title="1.1、redis的优缺点？（招银网络科技）"></a>1.1、redis的优缺点？（招银网络科技）</h2><p><strong>缺点：</strong></p><p>由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然Redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p><p>如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</p><p>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务。</p><h2 id="2、为什么要用缓存？（美团）"><a href="#2、为什么要用缓存？（美团）" class="headerlink" title="2、为什么要用缓存？（美团）"></a>2、为什么要用缓存？（美团）</h2><p>因为<code>redis</code>的高性能与高并发。</p><h2 id="3、为什么redis单线程还支持高并发？（美团）"><a href="#3、为什么redis单线程还支持高并发？（美团）" class="headerlink" title="3、为什么redis单线程还支持高并发？（美团）"></a>3、为什么redis单线程还支持高并发？（美团）</h2><p>因为<code>Redis</code>是基于内存的操作，CPU不是<code>Redis</code>的瓶颈，<code>Redis</code>的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现而且省去了很多上下文切换线程的时间，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p><code>redis</code>使用**<code>epoll</code>多路I/O复用技术**，单个线程可以处理大量的并发连接。<code>epoll</code>是一种高效的多路复用技术。</p><h2 id="4、为什么要用redis而不是map或者guava做缓存？（shopee）"><a href="#4、为什么要用redis而不是map或者guava做缓存？（shopee）" class="headerlink" title="4、为什么要用redis而不是map或者guava做缓存？（shopee）"></a>4、为什么要用redis而不是map或者guava做缓存？（shopee）</h2><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 <code>jvm</code> 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，<strong>缓存不具有一致性</strong>。</p><p>使用 <code>redis</code> 或 <code>memcached</code> 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 <code>redis</code> 或 <code>memcached</code>服务的高可用，整个程序架构上较为复杂。</p><h2 id="5、Redis数据结构？string与hash的区别？（美团）（字节）"><a href="#5、Redis数据结构？string与hash的区别？（美团）（字节）" class="headerlink" title="5、Redis数据结构？string与hash的区别？（美团）（字节）"></a>5、Redis数据结构？string与hash的区别？（美团）（字节）</h2><p>string、list、hash、set、zset。</p><p>String多应用于简单的键值对缓存；hash储存结构化数据，比如一个对象。</p><h2 id="6、redis应用场景？"><a href="#6、redis应用场景？" class="headerlink" title="6、redis应用场景？"></a>6、redis应用场景？</h2><p>计数器、分布式会话缓存、分布式锁实现等等。</p><h2 id="7、跳跃表（skipList）？（字节）（shopee）"><a href="#7、跳跃表（skipList）？（字节）（shopee）" class="headerlink" title="7、跳跃表（skipList）？（字节）（shopee）"></a>7、跳跃表（skipList）？（字节）（shopee）</h2><p><code>SkipList</code>是在<strong>有序链表</strong>的基础上进行了扩展，解决了有序链表结构查找特定值困难的问题，查找特定值的时间复杂度为<code>O(logn)</code>，他是一种可以代替平衡树的数据结构。</p><p>它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，就能轻松实现一个 <code>SkipList</code>。</p><h2 id="7、redis持久化机制？（有赞）（跟谁学）（滴滴）"><a href="#7、redis持久化机制？（有赞）（跟谁学）（滴滴）" class="headerlink" title="7、redis持久化机制？（有赞）（跟谁学）（滴滴）"></a>7、redis持久化机制？（有赞）（跟谁学）（滴滴）</h2><ol><li><strong>RDB</strong>：开启一个新的线程来完成往<code>rdb</code>文件中的写操作。主线程继续处理命令。<strong>使用单独的子线程来进行持久化</strong>。主线程不进行任何的IO操作。保证<code>redis</code>的高性能。缺点是可能会丢失一些数据。</li><li><strong>AOF</strong> ：AOF持久化(即Append Only File持久化)，则是将<code>Redis</code>执行的每次写命令记录到单独的日志文件中，当重启<code>Redis</code>会重新将持久化的日志中文件恢复数据。AOF有一个<strong>重写模式</strong>，当日志文件过大时可以对其进行压缩。AOF往往效率低于RDB一些。</li></ol><p><strong>AOF的追写策略</strong>：建议使用每秒同步一次<code>（everysec）</code>策略。</p><p><strong>rewrite机制</strong>：rewrite会记录上次重写时AOF文件的大小，当AOF文件是上一次大小的二倍且大于64M时触发。</p><h2 id="8、如何选择合适的持久化方式？"><a href="#8、如何选择合适的持久化方式？" class="headerlink" title="8、如何选择合适的持久化方式？"></a>8、如何选择合适的持久化方式？</h2><p>一般来说两者配合使用效果最佳，当 <code>Redis</code> 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p><p>如果可以容忍数分钟内的数据丢失，可以只选用RDB方式，还比较快。</p><p>不推荐只使用AOF方式。</p><h2 id="9、过期键的删除策略？（美团）"><a href="#9、过期键的删除策略？（美团）" class="headerlink" title="9、过期键的删除策略？（美团）"></a>9、过期键的删除策略？（美团）</h2><ul><li><strong>定时过期</strong>：每个设置过期时间的key都需要创建一个<strong>定时器</strong>，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li><li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li></ul><h2 id="10、redis设置键的过期时间以及永不过期命令是什么？"><a href="#10、redis设置键的过期时间以及永不过期命令是什么？" class="headerlink" title="10、redis设置键的过期时间以及永不过期命令是什么？"></a>10、redis设置键的过期时间以及永不过期命令是什么？</h2><p>expire设置过期时间</p><p>persist设置键永不过期，多用于热点数据。</p><h2 id="11、redis的内存淘汰策略有哪些？"><a href="#11、redis的内存淘汰策略有哪些？" class="headerlink" title="11、redis的内存淘汰策略有哪些？"></a>11、redis的内存淘汰策略有哪些？</h2><ul><li><code>noeviction</code>：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是<strong>最常用</strong>的）</li><li><code>allkeys-random</code>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li><li><code>volatile-lru</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li><code>volatile-random</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li><code>volatile-ttl</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</li></ul><h2 id="12、redis线程模型？（shopee）"><a href="#12、redis线程模型？（shopee）" class="headerlink" title="12、redis线程模型？（shopee）"></a>12、redis线程模型？（shopee）</h2><p><code>redis</code>以<strong>单线程</strong>模式运行，但是通过使用 I/O 多路复用来监听多个套接字（socket）， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 <code>redis</code> 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 <code>Redis</code> 内部单线程设计的简单性。</p><h2 id="13、redis主从复制？（shopee）"><a href="#13、redis主从复制？（shopee）" class="headerlink" title="13、redis主从复制？（shopee）"></a>13、redis主从复制？（shopee）</h2><p><strong>主从连接过程：</strong></p><ol><li>从服务器连接主服务器，发送SYNC命令。主服务器接收到SYNC命名后，开始执行<strong>BGSAVE</strong>命令生成<strong>RDB文件</strong>并使用缓冲区记录此后执行的所有写命令。</li><li>主服务器创建<strong>快照文件</strong>，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li><li>一旦主机挂了，从机会原地待命，但是使用 <strong><code>salveof no one</code></strong> 命令会<strong>使从机反仆为主</strong>。</li></ol><p><strong>作用：</strong>数据冗余、故障恢复、负载均衡、高可用的基石。使用slave of 命令将某一台redis变为从机。</p><h2 id="14、redis哨兵机制？（shopee）（滴滴）（新浪）"><a href="#14、redis哨兵机制？（shopee）（滴滴）（新浪）" class="headerlink" title="14、redis哨兵机制？（shopee）（滴滴）（新浪）"></a>14、redis哨兵机制？（shopee）（滴滴）（新浪）</h2><ol><li>Sentinel(哨兵) <strong>进程</strong>是用于监控 <code>Redis</code> 集群中 Master 主服务器工作的状态</li><li>在 Master 主服务器发生故障的时候，可以实现 Master 和 Slave 服务器的切换，保证系统的高可用（High Availability）</li><li>为了防止<code>脑裂</code>发生，节点个数一般配置为 2n+1。</li></ol><h2 id="15、redis集群？redis-的-key-是如何寻址的？分布式寻址都有哪些算法？了解一致性-hash-算法吗？（滴滴）"><a href="#15、redis集群？redis-的-key-是如何寻址的？分布式寻址都有哪些算法？了解一致性-hash-算法吗？（滴滴）" class="headerlink" title="15、redis集群？redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？（滴滴）"></a>15、redis集群？redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？（滴滴）</h2><p><strong>为什么有了哨兵模式还需要集群？</strong></p><p><code>redis</code>的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台<code>redis</code>服务器都存储相同的数据，很<strong>浪费内存</strong>，所以在redis3.0上加入了cluster模式，实现的<code>redis</code>的<strong>分布式存储</strong>，也就是说每台<code>redis</code>节点上存储不同的内容。</p><p><strong>数据分配策略？</strong></p><p>采用一种叫做<code>哈希槽</code> (hash slot)的方式来分配数据，<code>redis cluster</code> 默认分配了 16384 个slot。将key的 <code>hashCode % 16384</code>得出数据的槽位。</p><p><strong>分布式寻址算法</strong></p><ol><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li><code>redis</code> cluster（集群） 的 hash slot （槽）算法</li></ol><h2 id="15-2、一致性hash说一下-（跟谁学）"><a href="#15-2、一致性hash说一下-（跟谁学）" class="headerlink" title="15.2、一致性hash说一下?（跟谁学）"></a>15.2、一致性hash说一下?（跟谁学）</h2><p>首先面对海量数据，一台<code>redis</code>肯定是不够用的，一致性hash算法主要是用来将数据按照一定的算法规律存储到指定的<code>redis</code>服务器中。</p><p>常规的hash算法会导致一个问题：当<code>redis</code>的实例个数变了那么所有的hash值都需要重新计算，这是非常耗时的。一致性hash的出现解决了这种问题。</p><ol><li>hash(IP) % 2^32 -1 求出<code>redis</code>主机在圆环中的位置，</li><li>使用hash(key) % 2^32-1求出数据在环上的位置，从该位置顺时针查找到的第一个主机即该数据存储的位置。</li><li>这样一来及有一个标准化的计算过程了。</li></ol><h2 id="16、什么是RedLock？"><a href="#16、什么是RedLock？" class="headerlink" title="16、什么是RedLock？"></a>16、什么是RedLock？</h2><p><code>Redis</code> 官方站提出了一种权威的基于 <code>Redis</code> 实现分布式锁的方式名叫 *<code>Redlock</code>*，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p><ol><li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li><li>容错性：只要大部分 <code>Redis</code> 节点存活就可以正常提供服务</li></ol><h2 id="17、缓存雪崩、击穿、穿透？（美团）（滴滴）"><a href="#17、缓存雪崩、击穿、穿透？（美团）（滴滴）" class="headerlink" title="17、缓存雪崩、击穿、穿透？（美团）（滴滴）"></a>17、缓存雪崩、击穿、穿透？（美团）（滴滴）</h2><p>穿透：</p><p>（1）  <strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p><p>（2）  <strong>设置可访问的名单（白名单）：</strong></p><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><p>（3）  <strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p><p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><p><strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p><p>击穿：</p><p><strong>（1****）预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p><p><strong>（2****）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p><p><strong>（3****）使用锁：</strong></p><p>（1）  就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p><p>（2）  先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p><p>（3）  当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p><p>（4）  当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p><p>雪崩：</p><p><strong>（1）</strong>  <strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</p><p><strong>（2）</strong>  <strong>使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p><p><strong>（3）</strong>  <strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><p><strong>（4）</strong>  <strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="18、缓存预热？（百度）"><a href="#18、缓存预热？（百度）" class="headerlink" title="18、缓存预热？（百度）"></a>18、缓存预热？（百度）</h2><p>秒杀开始前，商品数据以及库存都预热到redis。</p><h2 id="19、Redis支持的客户端？"><a href="#19、Redis支持的客户端？" class="headerlink" title="19、Redis支持的客户端？"></a>19、Redis支持的客户端？</h2><p><code>Redisson</code>、<code>jedis</code>、<code>lettuce</code>等等，官方推荐使用<code>Redisson</code>。</p><h2 id="20、Jedis与Redisson对比有什么优缺点？（美团）"><a href="#20、Jedis与Redisson对比有什么优缺点？（美团）" class="headerlink" title="20、Jedis与Redisson对比有什么优缺点？（美团）"></a>20、Jedis与Redisson对比有什么优缺点？（美团）</h2><p><code>Jedis</code>是<code>Redis</code>的Java实现的客户端，其API提供了比较全面的<code>Redis</code>命令的支持；<code>Redisson</code>实现了<strong>分布式和可扩展</strong>的Java数据结构，和<code>Jedis</code>相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等<code>Redis</code>特性。<code>Redisson</code>的宗旨是促进使用者对<code>Redis</code>的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><p><code>Redisson</code>解决了锁的自动续期问题，只要业务还在执行，<code>Redisson</code>就会为锁自动续期。</p><h2 id="21、redis事务？（有赞）（跟谁学）"><a href="#21、redis事务？（有赞）（跟谁学）" class="headerlink" title="21、redis事务？（有赞）（跟谁学）"></a>21、redis事务？（有赞）（跟谁学）</h2><p><code>Redis</code> 事务的本质是通过**MULTI、EXEC、WATCH、discard **等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">multi : 标记一个事务块的开始（ <span class="hljs-type">queued</span> ）<br>exec : 执行所有事务块的命令 （ 一旦执行<span class="hljs-type">exec</span>后，之前加的监控锁都会被取消掉 ）　<br>discard : 取消事务，放弃事务块中的所有命令<br>unwatch : 取消<span class="hljs-type">watch</span>对所有key的监控<br></code></pre></td></tr></table></figure><ol><li>如果一个事务中的命令出现错误，那么所有命令都不会执行。</li><li><code>Redis</code>事务<strong>不保证多条指令的原子性</strong>。</li><li>基于Lua脚本可以保证脚本中的指令一次性按顺序执行。</li></ol><h2 id="22、redis与memcached的区别？（平安科技）"><a href="#22、redis与memcached的区别？（平安科技）" class="headerlink" title="22、redis与memcached的区别？（平安科技）"></a>22、redis与memcached的区别？（平安科技）</h2><ol><li><strong>支持存储的数据类型</strong>：<code>redis</code>支持五种类型。<code>memcached</code>支持文本类型与二进制类型。</li><li><strong>网络IO模型</strong>：<code>redis</code>是单线程的多路IO复用模型，<code>memcached</code>是多线程的非阻塞IO模式。</li><li><strong><code>redis</code>支持数据持久化</strong>，<code>memcached</code>不支持</li><li>使用场景：<code>redis</code>适用于复杂的数据结构环境，有持久化需求。<code>memcached</code>适用于纯&lt;k,v&gt;且数据量矩大的环境下。</li></ol><h2 id="23、redis常见的性能问题与对应的解决方案？（新浪）（shopee）"><a href="#23、redis常见的性能问题与对应的解决方案？（新浪）（shopee）" class="headerlink" title="23、redis常见的性能问题与对应的解决方案？（新浪）（shopee）"></a>23、redis常见的性能问题与对应的解决方案？（新浪）（shopee）</h2><ol><li><strong>Master最好不要做任何持久化工作</strong>，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li><li><strong>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次</strong>。</li><li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li><li>尽量避免在压力较大的主库上增加从库</li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li></ol><h2 id="24、假如Redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来？（字节）"><a href="#24、假如Redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来？（字节）" class="headerlink" title="24、假如Redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来？（字节）"></a>24、假如Redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来？（字节）</h2><p><strong>keys</strong>指令可以扫描得出指定模式的key列表</p><p>但是问题是由于<code>redis</code>是单线程的，<strong>keys指令会导致线程阻塞一段时间</strong>，此时的线上服务会有短暂停顿直到keys指令执行完毕。</p><p>使用<strong>scan</strong>指令可以做到<strong>无阻塞</strong>的提取出指定模式的key列表。但有一定的重复几率。再做一遍去重就🆗。</p><h2 id="25、布隆过滤器了解吗？（滴滴）（字节）"><a href="#25、布隆过滤器了解吗？（滴滴）（字节）" class="headerlink" title="25、布隆过滤器了解吗？（滴滴）（字节）"></a>25、布隆过滤器了解吗？（滴滴）（字节）</h2><p><strong>解决缓存穿透的问题。</strong></p><p>是<code>redis</code>中的一种数据结构，它将MySQL数据库中所有可能存在的数据都缓存到布隆过滤器中。当攻击者访问不存在的数据时<strong>迅速返回</strong>避免请求打到数据库上导致数据库宕机问题。</p><p><strong>原理：</strong></p><p>Bloom Filter 是一种空间效率很高的<strong>随机数据结构</strong>，Bloom filter 可以看做是对 bit-map 的扩展。当一个元素被加入集合时，通过 <strong>K 个 Hash 函数</strong>将这个元素映射成一个位阵列（Bit array）中的 K 个点，把它们置为 1。 检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它。 <strong>值得注意的是</strong>：如果这些点有任何一个 0，则被检索元素一定不在。 如果都是 1，则被检索元素很可能在。</p><h2 id="25-1、布隆过滤器的优、缺点？"><a href="#25-1、布隆过滤器的优、缺点？" class="headerlink" title="25.1、布隆过滤器的优、缺点？"></a>25.1、布隆过滤器的优、缺点？</h2><p><strong>二、优点</strong></p><p><strong>空间效率</strong>和<strong>查询效率</strong>都远远超过一般的算法，布隆过滤器存储空间和插入 / 查询时间都是常数O(k)。 另外, 散列函数相互之间没有关系，方便由硬件并行实现。 <strong>布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</strong></p><p><strong>三、缺点</strong></p><p>布隆过滤器的缺点和优点一样明显。 <strong>误算率</strong>是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表就可以。 另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><h2 id="26、redis分布式锁实现原理？（美团）（字节）"><a href="#26、redis分布式锁实现原理？（美团）（字节）" class="headerlink" title="26、redis分布式锁实现原理？（美团）（字节）"></a>26、redis分布式锁实现原理？（美团）（字节）</h2><ol><li>一个线程尝试去获取锁lock，通过<code>setnx</code>(lock，<code>uuid</code>，过期时间)。如果lock不存在就会设置成功，返回true，否则返回false。</li><li>获取分布式锁成功之后，需要使用<code>expire</code>命令设置锁有效期，防止死锁。</li><li>执行相关业务逻辑</li><li>释放锁，首先获取到lock对应的value，将此value与<code>uuid</code>对比，如果相同的话执行delete指令删除锁。注意！上述两个步骤需要保证<strong>原子性</strong>。需要使用<code>lua</code>脚本。</li></ol><h2 id="27、Redis针对数据结构做了哪些优化？（美团）"><a href="#27、Redis针对数据结构做了哪些优化？（美团）" class="headerlink" title="27、Redis针对数据结构做了哪些优化？（美团）"></a>27、Redis针对数据结构做了哪些优化？（美团）</h2><p>redis数据模型：</p><p>在Redis中，会给每一个key-value键值对分配一个字典实体，就是<code>dicEntry</code>。<code>dicEntry</code>包含三部分： <strong>key的指针、val的指针、next指针</strong>，next指针指向下一个dicteEntry形成链表，这个next指针可以将多个哈希值相同的键值对链接在一起，<strong>通过链地址法来解决哈希冲突的问题</strong></p><p><a href="https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/images/redis%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png"><img src="https://github.com/lokles/Web-Development-Interview-With-Java/raw/main/images/redis%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" alt="img"></a></p><ul><li><strong>sds</strong> ：<strong>Simple Dynamic String</strong>，简单动态字符串，存储字符串数据。</li><li><strong>redisObject</strong>：Redis的5种常用类型都是以RedisObject来存储的，redisObject中的<strong>type</strong>字段指明了值的数据类型（也就是5种基本类型)。<strong>ptr</strong>字段指向对象所在的地址。</li></ul><p>1、String： sds实现，自定义类型加入了长度，每次获取字符串长度的时间复杂度就是O(1)，而利用len和free属性对追加字符串进行优化，也可以降低重新分配内存的次数。</p><p>2、Hash： zip-list 或者 hash-table（数组+链表）扩容机制采用渐进式扩容。</p><p>3、Set： int-Set</p><p>4、Zset： skip-list</p><p>4、List： zip-list -&gt; linked-list -&gt; quick-list （前两者合并之后创建了快速链表）</p><h2 id="28、redis是如何保证原子操作的？（美团）（新浪）"><a href="#28、redis是如何保证原子操作的？（美团）（新浪）" class="headerlink" title="28、redis是如何保证原子操作的？（美团）（新浪）"></a>28、redis是如何保证原子操作的？（美团）（新浪）</h2><p>Redis是单线程的。在单线程程序中，任务一个一个地做，必须做完一个任务后，才会去做另一个任务。因而redis的操作保证了原子性。</p><h2 id="29、什么命令会触发写RDB文件？（跟谁学）"><a href="#29、什么命令会触发写RDB文件？（跟谁学）" class="headerlink" title="29、什么命令会触发写RDB文件？（跟谁学）"></a>29、什么命令会触发写RDB文件？（跟谁学）</h2><p>BGSAVE：后台处理，不会阻塞工作线程。</p><p>SAVE：会导致工作线程的阻塞。</p><h2 id="30、知道大Key问题吗？（滴滴）"><a href="#30、知道大Key问题吗？（滴滴）" class="headerlink" title="30、知道大Key问题吗？（滴滴）"></a>30、知道大Key问题吗？（滴滴）</h2><p>由于Redis主线程为单线程模型，大key也会带来一些问题，如：</p><ol><li>集群模式在slot分片均匀情况下，会出现数据和查询倾斜情况，部分有大key的Redis节点占用内存多，QPS高。</li><li>大key相关的删除或者自动过期时，会出现qps突降或者突升的情况，极端情况下，会造成主从复制异常，Redis服务阻塞无法响应请求。</li></ol><p><strong>redis4.0之前的大key的发现与删除方法</strong></p><ul><li><code>redis-rdb-tools</code>工具。<code>redis</code>实例上执行<code>bgsave</code>，然后对生成的<code>rdb</code>文件进行分析，找到其中的大KEY。</li><li><code>redis-cli --bigkeys</code>命令。可以找到某个实例5种数据类型(String、hash、list、set、zset)的最大key。</li></ul><p>由于在redis4.0前，没有<strong>lazy free</strong>机制；针对扫描出来的大key，DBA只能通过hscan、sscan、zscan方式渐进删除若干个元素，但面对过期键删除的场景，这种取巧的删除就无能为力。我们只能祈祷自动清理过期key刚好在系统低峰时，降低对业务的影响。</p><p><strong>Redis 4.0之后的大key的发现与删除方法</strong></p><p>Redis 4.0引入了memory usage命令和lazy free机制，不管是对大key的发现，还是解决大key删除或者过期造成的阻塞问题都有明显的提升</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/13/hot100/"/>
    <url>/2022/08/13/hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="hot100"><a href="#hot100" class="headerlink" title="hot100"></a>hot100</h1><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1.链表"></a>1.链表</h2><h3 id="1-2-两数相加"><a href="#1-2-两数相加" class="headerlink" title="1. 2-两数相加"></a>1. 2-两数相加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br>            <br>            carry = sum / <span class="hljs-number">10</span>;<br>            sum = sum % <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//将求和数赋值给新链表的节点，</span><br>            <span class="hljs-comment">//注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。</span><br>            <span class="hljs-comment">//所以这个时候要创一个新的节点，将值赋予节点</span><br>            <span class="hljs-comment">//cur.next.val= sum;</span><br>            <span class="hljs-comment">//如果这里用cur.next.val= sum; 会空指针异常 因为cur本身指向pre，有地址指向 cur.next已经指空了，</span><br>            <span class="hljs-comment">//再cur.next.val就空指针异常</span><br>            <span class="hljs-comment">//此时需要新的地址，让cur.next有一个指向 而不是给cur.next.val赋值</span><br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br><br>            cur = cur.next;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>)<br>                l1 = l1.next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>)<br>                l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) &#123;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-19-删除链表的倒数第K个节点"><a href="#2-19-删除链表的倒数第K个节点" class="headerlink" title="2. 19-删除链表的倒数第K个节点"></a>2. 19-删除链表的倒数第K个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List <span class="hljs-title function_">removePointFromEnd</span><span class="hljs-params">(List head,<span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-type">List</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br><br>    <span class="hljs-comment">//快慢节点 删除倒数第几个 快指针移动几次 然后快慢同时移动 当快指针指空 慢指针找到位置 此时借助辅助接点删除第K个节点</span><br>    <span class="hljs-type">List</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">List</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-keyword">while</span> (index-- &gt; <span class="hljs-number">0</span>)&#123;<br>        fast = fast.next;<br>    &#125;<br>    <span class="hljs-type">List</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>)&#123;<br>        prev = slow;<br>        slow = slow.next;<br>        fast = fast.next;<br>    &#125;<br>    prev.next = slow.next;<br>    slow.next = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-21-合并两个有序链表"><a href="#3-21-合并两个有序链表" class="headerlink" title="3. 21-合并两个有序链表"></a>3. 21-合并两个有序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个新链表 两个旧链比较val的大小往新链表中添加 剩下的再添加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1 ,ListNode list2)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> res;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val)&#123;<br>                cur.next = list1;<br>                cur = cur.next;<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list2;<br>                cur = cur.next;<br>                list2 = list2.next;<br>            &#125;<br>        &#125;<br>        cur.next = (list1 != <span class="hljs-literal">null</span> ? list1 : list2);<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23-合并K个升序链表"></a>23-合并K个升序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">   <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><p>使用递归</p><p>设两个变量 left，right下标 ，通过left，right计算出mid下标，和midVlu中间值</p><p>比较目标值和中间值，如果目标大于中间，说明目标值小了，需要向右查找，因此查找范围为mid+1，到right</p><p>如果目标小于中间，说明目标值大了，需要向左查找，因此查找的范围为0到mid-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> searchNum(nums,left,right,target);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right)&#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">midVlu</span> <span class="hljs-operator">=</span> nums[mid];<br><br>    <span class="hljs-keyword">if</span> (target &gt; midVlu)&#123;<br>        <span class="hljs-keyword">return</span> searchNum(nums,mid + <span class="hljs-number">1</span>,right,target);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; midVlu)&#123;<br>        <span class="hljs-keyword">return</span> searchNum(nums,<span class="hljs-number">0</span>,mid - <span class="hljs-number">1</span>,target);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2.移除元素"></a>2.移除元素</h3><p>快慢指针的经典应用</p><p>快慢都指头，快指针一直移动，如果快指针指向的值不等于val，慢指针跟上，如果相等，慢指针等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> slow;<br>    <span class="hljs-keyword">for</span> (slow = <span class="hljs-number">0</span> ; fast &lt; nums.length ;fast++)&#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != val)&#123;<br>            nums[slow] = nums[fast];<br>            slow++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3.有序数组的平方"></a>3.有序数组的平方</h3><p>因为数组是从小到大有负数，所以负数的平方反而可能会最大</p><p>因此从左右两侧一起比较，如果负数的平方大，就让他进数组的末尾，如果是正数平方大，让其进数组末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] nums)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">if</span> (nums[left] * nums[left] &gt;= nums[right] * nums[right])&#123;<br>            res[i] = nums[left] * nums[left++];<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            res[i] = nums[right] * nums[right--];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-长度最小的子数组"><a href="#4-长度最小的子数组" class="headerlink" title="4.长度最小的子数组"></a>4.长度最小的子数组</h3><p>返回的是数组的长度</p><p>先找到满足条件值最小的数组，然后返回数组的长度</p><p>滑动窗口，当数组长度满足时，进行判断，不断尝试让left右移减小数组长度，如此至遍历整个数组为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target,<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; right &lt; nums.length ; right++)&#123;<br>        sum += nums[right];<br>        <span class="hljs-keyword">while</span> (sum &gt;= target)&#123;<br>            result = Math.min(result,right - left + <span class="hljs-number">1</span>);<br>            sum -= nums[left++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-螺旋矩阵2"><a href="#5-螺旋矩阵2" class="headerlink" title="5.螺旋矩阵2"></a>5.螺旋矩阵2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/08/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器配置地址"><a href="#服务器配置地址" class="headerlink" title="服务器配置地址"></a>服务器配置地址</h1><h2 id="redis-usr-local-bin-redis"><a href="#redis-usr-local-bin-redis" class="headerlink" title="redis: usr/local/bin/redis"></a>redis: usr/local/bin/redis</h2><p>redis配置文件位置： myredis/redis.conf</p><p>redis启动命令：在redis-server的目录下，输入./redis-server /myredis/redis.conf </p><p>配置文件中配了后台启动的方法</p><p>redis密码 123456Zxl 可以在登录后进入客户端 输入auth 123456Zxl</p><p>或者登录的时候./redis-cli -p6379 -a 123456Zxl</p><h2 id="mysql：已经自启动了"><a href="#mysql：已经自启动了" class="headerlink" title="mysql：已经自启动了"></a>mysql：已经自启动了</h2><h2 id="tomcat："><a href="#tomcat：" class="headerlink" title="tomcat："></a>tomcat：</h2><h1 id="博客发布方式"><a href="#博客发布方式" class="headerlink" title="博客发布方式"></a>博客发布方式</h1><p>hexo d：更新</p><p>hexo g：上传</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/13/hello-world/"/>
    <url>/2022/08/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/24/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2/"/>
    <url>/2022/07/24/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="谷粒学院"><a href="#谷粒学院" class="headerlink" title="谷粒学院"></a>谷粒学院</h1><p>遇到的问题</p><p>1.前后端登录出现No ‘Access-Control-Allow-Origin 跨域问题</p><p>如果通过一个地址访问另一个地址，这个过程中有三个地方不一样，就会出现跨域</p><p>1.访问协议 http https</p><p>2.ip地址 192.168.101.1     124.220.160.3</p><p>3.端口号 8001 9528</p><p>解决方式：在后端接口controller添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CrossOrigin</span> <span class="hljs-comment">// 解决跨域问题</span><br></code></pre></td></tr></table></figure><p>2.后端传参给前端问题，什么时候用data什么时候不用？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//删除讲师</span><br>   <span class="hljs-title function_">deleteTeacherId</span>(<span class="hljs-params">id</span>)&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>           <span class="hljs-attr">url</span>: <span class="hljs-string">`/eduservice/teacher/<span class="hljs-subst">$&#123;id&#125;</span>`</span>,<br>           <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;delete&#x27;</span>,<br>         &#125;)<br>   &#125;,<br>   <span class="hljs-comment">//添加讲师</span><br>   <span class="hljs-title function_">addTeacher</span>(<span class="hljs-params">teacher</span>)&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>           <span class="hljs-attr">url</span>: <span class="hljs-string">`/eduservice/teacher/addTeacher`</span>,<br>           <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>           <span class="hljs-attr">data</span>: teacher<br>         &#125;)<br>   &#125;,<br>   <span class="hljs-comment">//根据讲师id回显信息</span><br>   <span class="hljs-title function_">getTeacherInfo</span>(<span class="hljs-params">id</span>)&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>           <span class="hljs-attr">url</span>: <span class="hljs-string">`/eduservice/teacher/getTeacher/<span class="hljs-subst">$&#123;id&#125;</span>`</span>,<br>           <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>         &#125;)<br>   &#125;    <br></code></pre></td></tr></table></figure><p>以上为删除 添加 回显</p><p>可以看出来只有添加讲师有data传数据</p><p>再看后端接口怎么写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value = &quot;逻辑删除讲师&quot;)</span><br><span class="hljs-meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span><br><span class="hljs-comment">//mapping后面的参数是url后面跟的 会被PathVariable拿到给形参id使用</span><br><span class="hljs-keyword">public</span> R <span class="hljs-title function_">removeTeacher</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(name = &quot;id&quot;,value = &quot;讲师id&quot;,required = true)</span> <span class="hljs-meta">@PathVariable</span> String id)</span>&#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> teacherService.removeById(id);<br>    <span class="hljs-keyword">if</span> (flag)&#123;<br>        <span class="hljs-keyword">return</span> R.ok();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> R.error();<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//5.添加讲师的方法</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;添加讲师&quot;)</span><br>    <span class="hljs-meta">@PostMapping(&quot;addTeacher&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">addTeacher</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> EduTeacher eduTeacher)</span>&#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> teacherService.save(eduTeacher);<br>        <span class="hljs-keyword">if</span> (save)&#123;<br>            <span class="hljs-keyword">return</span> R.ok();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> R.error();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//6.根据讲师名进行查询</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;查询讲师&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;getTeacher/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">getTeacher</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span>&#123;<br>        <span class="hljs-type">EduTeacher</span> <span class="hljs-variable">eduTeacher</span> <span class="hljs-operator">=</span> teacherService.getById(id);<br>        <span class="hljs-keyword">return</span> R.ok().data(<span class="hljs-string">&quot;teacher&quot;</span>,eduTeacher);<br>    &#125;<br></code></pre></td></tr></table></figure><p>后端的post方法有@RequestBody等待接受参数，这个参数从前端传过来，后端调用service等完成数据库的操作</p><p>前端的vue中用data定义变量和初始值，下面的methods中添加方法，调用js中的具体功能，如果是后端需要从前端接受数据，那就把data中的数据传给methods，methods调用js功能时把data参数传过去，在js中用data来接收，如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//添加讲师</span><br>    <span class="hljs-title function_">addTeacher</span>(<span class="hljs-params">teacher</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">`/eduservice/teacher/addTeacher`</span>,<br>            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>            <span class="hljs-attr">data</span>: teacher<br>          &#125;)<br>    &#125;,<br></code></pre></td></tr></table></figure><p>如果后端不需要从前端接受数据，那就只在methods中调用js方法即可，如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//删除讲师</span><br><span class="hljs-title function_">deleteTeacherId</span>(<span class="hljs-params">id</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">`/eduservice/teacher/<span class="hljs-subst">$&#123;id&#125;</span>`</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;delete&#x27;</span>,<br>      &#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><p>3.当在页面点击修改 再点添加讲师时，数据还是修改的数据，按理应该是清空的状态</p><p>是路由问题导致的，添加了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-comment">//监听</span><br>    $route(to, <span class="hljs-keyword">from</span>) &#123;<br>      <span class="hljs-comment">//路由变化的方式</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();<br>    &#125;,<br>  &#125;,<br>      <br><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>) &#123;<br>        <span class="hljs-comment">//从路径获取id值</span><br>        <span class="hljs-keyword">const</span> id = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-comment">//调用根据id查询的方法</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getInfo</span>(id);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 路径没有id值 做添加</span><br>        <span class="hljs-comment">//清空表单</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">teacher</span> = &#123;&#125;;<br>      &#125;<br>    &#125;,<br> &#125;<br></code></pre></td></tr></table></figure><p>监听路由变化，如果变了那就切换路由 </p><p>4.上传头像后 如果想要更改图像 界面还是之前成功的界面</p><p>办法：让key每次加1，唯一标识不一样了，他的记录就不一样了</p><p>5.路由跳转 一般是在进行添加后 跳转到主页面的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">this.$router.push(&#123; path: &quot;/teacher/table&quot; &#125;);<br></code></pre></td></tr></table></figure><p>这里的路径取决于route路径下 index中的path的路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/teacher&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-title class_">Layout</span>,<br>   <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/teacher/table&#x27;</span>,<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;讲师管理&#x27;</span>,<br>   <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;讲师管理&#x27;</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;example&#x27;</span> &#125;,<br>   <span class="hljs-attr">children</span>: [<br>     &#123;<br>       <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;table&#x27;</span>,<br>       <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;讲师列表&#x27;</span>,<br>       <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;@/views/edu/teacher/list&#x27;</span>),<br>       <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;讲师列表&#x27;</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;table&#x27;</span> &#125;<br>     &#125;,<br></code></pre></td></tr></table></figure><p>6.课程管理 添加课程中 课程分类一级选择后二级没显示 </p><p>从页面f12可看出 subjectOneList没有被定义</p><p>因为这个subjectOneList是在data中定义的 所以不能直接调用 要在前面加this关键字，添加后问题解决</p><p>7.当我选择了一个一级分类 再选二级分类后 更改一级分类，二级分类并没有改变，还是之前一级分类下面的内容</p><p>8.课程管理添加章节 第二步添加课程时全局异常</p><p><img src="C:\Users\ZhangXL\AppData\Roaming\Typora\typora-user-images\image-20220614141018387.png" alt="image-20220614141018387"></p><p>接口中报这个错误 是因为前端没有传course_id进去</p><p><img src="C:\Users\ZhangXL\AppData\Roaming\Typora\typora-user-images\image-20220614141102648.png" alt="image-20220614141102648"></p><p>chapter对象中的id为空</p><p>解决办法 在调用需要使用course_id的方法之前，把值赋给对象的id属性即可</p><p><img src="C:\Users\ZhangXL\AppData\Roaming\Typora\typora-user-images\image-20220614141210265.png" alt="image-20220614141210265"></p><p>9.测试对章节和小节的操作时出现了问题</p><p>如果在章节中添加小节 没有问题</p><p>我再添加小节 没有问题</p><p>如果我修改小节 没有问题</p><p>但是如果我先修改小节 在添加小节 就出现了问题 因为此时有video的id，添加小节依旧走修改小节的方法 </p><p>解决办法：每次修改完小节后 将this.video.id = ‘ ‘ 即可</p><p>10.当我调用自己写的sql语句的时候，出现异常</p><p><img src="C:\Users\ZhangXL\AppData\Roaming\Typora\typora-user-images\image-20220614213435572.png" alt="image-20220614213435572"></p><p>数据绑定异常 经查阅可得知是maven的问题 在target的class文件中只有.class文件，没有xml文件 找不到sql语句</p><p>解决方式：</p><p>1.复制xml文件到target中</p><p>2.把xml文件放到resources目录中</p><p>3。推荐使用 通过配置实现</p><p>​    （1）pom.xml</p><p>​    （2）application.properties</p><p>11 CmsApplication启动时出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="hljs-string">&#x27;bannerAdminController&#x27;</span>: Unsatisfied dependency expressed through field <span class="hljs-string">&#x27;bannerService&#x27;</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="hljs-string">&#x27;crmBannerServiceImpl&#x27;</span>: Unsatisfied dependency expressed through field <span class="hljs-string">&#x27;baseMapper&#x27;</span>; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="hljs-string">&#x27;crmBannerMapper&#x27;</span> defined in file [D:\learn\guli_parent\service\service_cms\target\classes\com\educms\mapper\CrmBannerMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Property <span class="hljs-string">&#x27;sqlSessionFactory&#x27;</span> or <span class="hljs-string">&#x27;sqlSessionTemplate&#x27;</span> are required<br><br></code></pre></td></tr></table></figure><p>删掉主启动类的@ComponentScan({“com”})，在serviceimpl加上@Service注解，问题解决，这里是尚硅谷有多一次层的atguigu，我直接删掉了，只保留了com，创建bean失败</p><p>为什么要删除@ComponentScan? 为什么注解只能加在serviceimpl上？为什么mapper不用加？为什么加在service上不行？</p><p>12 redis中间件在idea失效</p><p>其他尝试均无异常 Windows连接工具连接服务器的redis成功 idea配置文件不起作用 </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
